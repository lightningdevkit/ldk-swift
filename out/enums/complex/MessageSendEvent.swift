import Foundation

#if SWIFT_PACKAGE
	import LDKHeaders
#endif


///
public typealias MessageSendEvent = Bindings.MessageSendEvent

extension Bindings {

	/// An event generated by ChannelManager which indicates a message should be sent to a peer (or
	/// broadcast to most peers).
	/// These events are handled by PeerManager::process_events if you are using a PeerManager.
	public class MessageSendEvent: NativeTypeWrapper {


		/// Set to false to suppress an individual type's deinit log statements.
		/// Only applicable when log threshold is set to `.Debug`.
		public static var enableDeinitLogging = true

		/// Set to true to suspend the freeing of this type's associated Rust memory.
		/// Should only ever be used for debugging purposes, and will likely be
		/// deprecated soon.
		public static var suspendFreedom = false

		private static var instanceCounter: UInt = 0
		internal let instanceNumber: UInt

		internal var cType: LDKMessageSendEvent?

		internal init(cType: LDKMessageSendEvent, instantiationContext: String) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
		}

		internal init(cType: LDKMessageSendEvent, instantiationContext: String, anchor: NativeTypeWrapper) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			self.dangling = true
			try! self.addAnchor(anchor: anchor)
		}

		internal init(
			cType: LDKMessageSendEvent, instantiationContext: String, anchor: NativeTypeWrapper, dangle: Bool = false
		) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			self.dangling = dangle
			try! self.addAnchor(anchor: anchor)
		}


		public enum MessageSendEventType {

			/// Used to indicate that we've accepted a channel open and should send the accept_channel
			/// message provided to the given peer.
			case SendAcceptChannel

			/// Used to indicate that we've initiated a channel open and should send the open_channel
			/// message provided to the given peer.
			case SendOpenChannel

			/// Used to indicate that a funding_created message should be sent to the peer with the given node_id.
			case SendFundingCreated

			/// Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
			case SendFundingSigned

			/// Used to indicate that a channel_ready message should be sent to the peer with the given node_id.
			case SendChannelReady

			/// Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
			case SendAnnouncementSignatures

			/// Used to indicate that a series of HTLC update messages, as well as a commitment_signed
			/// message should be sent to the peer with the given node_id.
			case UpdateHTLCs

			/// Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
			case SendRevokeAndACK

			/// Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
			case SendClosingSigned

			/// Used to indicate that a shutdown message should be sent to the peer with the given node_id.
			case SendShutdown

			/// Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
			case SendChannelReestablish

			/// Used to send a channel_announcement and channel_update to a specific peer, likely on
			/// initial connection to ensure our peers know about our channels.
			case SendChannelAnnouncement

			/// Used to indicate that a channel_announcement and channel_update should be broadcast to all
			/// peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
			///
			/// Note that after doing so, you very likely (unless you did so very recently) want to
			/// broadcast a node_announcement (e.g. via [`PeerManager::broadcast_node_announcement`]). This
			/// ensures that any nodes which see our channel_announcement also have a relevant
			/// node_announcement, including relevant feature flags which may be important for routing
			/// through or to us.
			///
			/// [`PeerManager::broadcast_node_announcement`]: crate::ln::peer_handler::PeerManager::broadcast_node_announcement
			case BroadcastChannelAnnouncement

			/// Used to indicate that a channel_update should be broadcast to all peers.
			case BroadcastChannelUpdate

			/// Used to indicate that a node_announcement should be broadcast to all peers.
			case BroadcastNodeAnnouncement

			/// Used to indicate that a channel_update should be sent to a single peer.
			/// In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
			/// private channel and we shouldn't be informing all of our peers of channel parameters.
			case SendChannelUpdate

			/// Broadcast an error downstream to be handled
			case HandleError

			/// Query a peer for channels with funding transaction UTXOs in a block range.
			case SendChannelRangeQuery

			/// Request routing gossip messages from a peer for a list of channels identified by
			/// their short_channel_ids.
			case SendShortIdsQuery

			/// Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
			/// emitted during processing of the query.
			case SendReplyChannelRange

			/// Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
			/// enable receiving gossip messages from the peer.
			case SendGossipTimestampFilter

		}

		public func getValueType() -> MessageSendEventType {
			switch self.cType!.tag {
				case LDKMessageSendEvent_SendAcceptChannel:
					return .SendAcceptChannel

				case LDKMessageSendEvent_SendOpenChannel:
					return .SendOpenChannel

				case LDKMessageSendEvent_SendFundingCreated:
					return .SendFundingCreated

				case LDKMessageSendEvent_SendFundingSigned:
					return .SendFundingSigned

				case LDKMessageSendEvent_SendChannelReady:
					return .SendChannelReady

				case LDKMessageSendEvent_SendAnnouncementSignatures:
					return .SendAnnouncementSignatures

				case LDKMessageSendEvent_UpdateHTLCs:
					return .UpdateHTLCs

				case LDKMessageSendEvent_SendRevokeAndACK:
					return .SendRevokeAndACK

				case LDKMessageSendEvent_SendClosingSigned:
					return .SendClosingSigned

				case LDKMessageSendEvent_SendShutdown:
					return .SendShutdown

				case LDKMessageSendEvent_SendChannelReestablish:
					return .SendChannelReestablish

				case LDKMessageSendEvent_SendChannelAnnouncement:
					return .SendChannelAnnouncement

				case LDKMessageSendEvent_BroadcastChannelAnnouncement:
					return .BroadcastChannelAnnouncement

				case LDKMessageSendEvent_BroadcastChannelUpdate:
					return .BroadcastChannelUpdate

				case LDKMessageSendEvent_BroadcastNodeAnnouncement:
					return .BroadcastNodeAnnouncement

				case LDKMessageSendEvent_SendChannelUpdate:
					return .SendChannelUpdate

				case LDKMessageSendEvent_HandleError:
					return .HandleError

				case LDKMessageSendEvent_SendChannelRangeQuery:
					return .SendChannelRangeQuery

				case LDKMessageSendEvent_SendShortIdsQuery:
					return .SendShortIdsQuery

				case LDKMessageSendEvent_SendReplyChannelRange:
					return .SendReplyChannelRange

				case LDKMessageSendEvent_SendGossipTimestampFilter:
					return .SendGossipTimestampFilter

				default:
					Bindings.print("Error: Invalid value type for MessageSendEvent! Aborting.", severity: .ERROR)
					abort()
			}

		}


		/// Frees any resources used by the MessageSendEvent
		internal func free() {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_free(self.cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = nativeCallResult


			return returnValue
		}

		/// Creates a copy of the MessageSendEvent
		internal func clone() -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult =
				withUnsafePointer(to: self.cType!) { (origPointer: UnsafePointer<LDKMessageSendEvent>) in
					MessageSendEvent_clone(origPointer)
				}


			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
		public class func initWithSendAcceptChannel(nodeId: [UInt8], msg: Bindings.AcceptChannel) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_accept_channel(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
		public class func initWithSendOpenChannel(nodeId: [UInt8], msg: Bindings.OpenChannel) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_open_channel(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
		public class func initWithSendFundingCreated(nodeId: [UInt8], msg: Bindings.FundingCreated) -> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_funding_created(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
		public class func initWithSendFundingSigned(nodeId: [UInt8], msg: Bindings.FundingSigned) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_funding_signed(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelReady-variant MessageSendEvent
		public class func initWithSendChannelReady(nodeId: [UInt8], msg: Bindings.ChannelReady) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_ready(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
		public class func initWithSendAnnouncementSignatures(nodeId: [UInt8], msg: Bindings.AnnouncementSignatures)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_announcement_signatures(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
		public class func initWithUpdateHtlcs(nodeId: [UInt8], updates: Bindings.CommitmentUpdate) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_update_htlcs(
				nodeIdPrimitiveWrapper.cType!, updates.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
		public class func initWithSendRevokeAndAck(nodeId: [UInt8], msg: Bindings.RevokeAndACK) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_revoke_and_ack(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
		public class func initWithSendClosingSigned(nodeId: [UInt8], msg: Bindings.ClosingSigned) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_closing_signed(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendShutdown-variant MessageSendEvent
		public class func initWithSendShutdown(nodeId: [UInt8], msg: Bindings.Shutdown) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_shutdown(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
		public class func initWithSendChannelReestablish(nodeId: [UInt8], msg: Bindings.ChannelReestablish)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_reestablish(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelAnnouncement-variant MessageSendEvent
		public class func initWithSendChannelAnnouncement(
			nodeId: [UInt8], msg: Bindings.ChannelAnnouncement, updateMsg: Bindings.ChannelUpdate
		) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_announcement(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!,
				updateMsg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
		public class func initWithBroadcastChannelAnnouncement(
			msg: Bindings.ChannelAnnouncement, updateMsg: Bindings.ChannelUpdate
		) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_channel_announcement(
				msg.dynamicallyDangledClone().cType!, updateMsg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
		public class func initWithBroadcastChannelUpdate(msg: Bindings.ChannelUpdate) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_channel_update(msg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
		public class func initWithBroadcastNodeAnnouncement(msg: Bindings.NodeAnnouncement) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_node_announcement(msg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
		public class func initWithSendChannelUpdate(nodeId: [UInt8], msg: Bindings.ChannelUpdate) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_update(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new HandleError-variant MessageSendEvent
		public class func initWithHandleError(nodeId: [UInt8], action: ErrorAction) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_handle_error(
				nodeIdPrimitiveWrapper.cType!, action.danglingClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
		public class func initWithSendChannelRangeQuery(nodeId: [UInt8], msg: Bindings.QueryChannelRange)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_range_query(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
		public class func initWithSendShortIdsQuery(nodeId: [UInt8], msg: Bindings.QueryShortChannelIds)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_short_ids_query(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
		public class func initWithSendReplyChannelRange(nodeId: [UInt8], msg: Bindings.ReplyChannelRange)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_reply_channel_range(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
		public class func initWithSendGossipTimestampFilter(nodeId: [UInt8], msg: Bindings.GossipTimestampFilter)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_gossip_timestamp_filter(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}


		public func getValueAsSendAcceptChannel() -> SendAcceptChannel? {
			if self.cType?.tag != LDKMessageSendEvent_SendAcceptChannel {
				return nil
			}

			return MessageSendEvent_LDKSendAcceptChannel_Body(
				cType: self.cType!.send_accept_channel,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendOpenChannel() -> SendOpenChannel? {
			if self.cType?.tag != LDKMessageSendEvent_SendOpenChannel {
				return nil
			}

			return MessageSendEvent_LDKSendOpenChannel_Body(
				cType: self.cType!.send_open_channel,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendFundingCreated() -> SendFundingCreated? {
			if self.cType?.tag != LDKMessageSendEvent_SendFundingCreated {
				return nil
			}

			return MessageSendEvent_LDKSendFundingCreated_Body(
				cType: self.cType!.send_funding_created,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendFundingSigned() -> SendFundingSigned? {
			if self.cType?.tag != LDKMessageSendEvent_SendFundingSigned {
				return nil
			}

			return MessageSendEvent_LDKSendFundingSigned_Body(
				cType: self.cType!.send_funding_signed,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendChannelReady() -> SendChannelReady? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelReady {
				return nil
			}

			return MessageSendEvent_LDKSendChannelReady_Body(
				cType: self.cType!.send_channel_ready,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendAnnouncementSignatures() -> SendAnnouncementSignatures? {
			if self.cType?.tag != LDKMessageSendEvent_SendAnnouncementSignatures {
				return nil
			}

			return MessageSendEvent_LDKSendAnnouncementSignatures_Body(
				cType: self.cType!.send_announcement_signatures,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsUpdateHtlcs() -> UpdateHTLCs? {
			if self.cType?.tag != LDKMessageSendEvent_UpdateHTLCs {
				return nil
			}

			return MessageSendEvent_LDKUpdateHTLCs_Body(
				cType: self.cType!.update_htl_cs, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendRevokeAndAck() -> SendRevokeAndACK? {
			if self.cType?.tag != LDKMessageSendEvent_SendRevokeAndACK {
				return nil
			}

			return MessageSendEvent_LDKSendRevokeAndACK_Body(
				cType: self.cType!.send_revoke_and_ack,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendClosingSigned() -> SendClosingSigned? {
			if self.cType?.tag != LDKMessageSendEvent_SendClosingSigned {
				return nil
			}

			return MessageSendEvent_LDKSendClosingSigned_Body(
				cType: self.cType!.send_closing_signed,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendShutdown() -> SendShutdown? {
			if self.cType?.tag != LDKMessageSendEvent_SendShutdown {
				return nil
			}

			return MessageSendEvent_LDKSendShutdown_Body(
				cType: self.cType!.send_shutdown, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendChannelReestablish() -> SendChannelReestablish? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelReestablish {
				return nil
			}

			return MessageSendEvent_LDKSendChannelReestablish_Body(
				cType: self.cType!.send_channel_reestablish,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendChannelAnnouncement() -> SendChannelAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKSendChannelAnnouncement_Body(
				cType: self.cType!.send_channel_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastChannelAnnouncement() -> BroadcastChannelAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastChannelAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKBroadcastChannelAnnouncement_Body(
				cType: self.cType!.broadcast_channel_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastChannelUpdate() -> BroadcastChannelUpdate? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastChannelUpdate {
				return nil
			}

			return MessageSendEvent_LDKBroadcastChannelUpdate_Body(
				cType: self.cType!.broadcast_channel_update,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastNodeAnnouncement() -> BroadcastNodeAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastNodeAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKBroadcastNodeAnnouncement_Body(
				cType: self.cType!.broadcast_node_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendChannelUpdate() -> SendChannelUpdate? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelUpdate {
				return nil
			}

			return MessageSendEvent_LDKSendChannelUpdate_Body(
				cType: self.cType!.send_channel_update,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsHandleError() -> HandleError? {
			if self.cType?.tag != LDKMessageSendEvent_HandleError {
				return nil
			}

			return MessageSendEvent_LDKHandleError_Body(
				cType: self.cType!.handle_error, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendChannelRangeQuery() -> SendChannelRangeQuery? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelRangeQuery {
				return nil
			}

			return MessageSendEvent_LDKSendChannelRangeQuery_Body(
				cType: self.cType!.send_channel_range_query,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendShortIdsQuery() -> SendShortIdsQuery? {
			if self.cType?.tag != LDKMessageSendEvent_SendShortIdsQuery {
				return nil
			}

			return MessageSendEvent_LDKSendShortIdsQuery_Body(
				cType: self.cType!.send_short_ids_query,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendReplyChannelRange() -> SendReplyChannelRange? {
			if self.cType?.tag != LDKMessageSendEvent_SendReplyChannelRange {
				return nil
			}

			return MessageSendEvent_LDKSendReplyChannelRange_Body(
				cType: self.cType!.send_reply_channel_range,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendGossipTimestampFilter() -> SendGossipTimestampFilter? {
			if self.cType?.tag != LDKMessageSendEvent_SendGossipTimestampFilter {
				return nil
			}

			return MessageSendEvent_LDKSendGossipTimestampFilter_Body(
				cType: self.cType!.send_gossip_timestamp_filter,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}


		internal func dangle(_ shouldDangle: Bool = true) -> MessageSendEvent {
			self.dangling = shouldDangle
			return self
		}


		internal func danglingClone() -> MessageSendEvent {
			let dangledClone = self.clone()
			dangledClone.dangling = true
			return dangledClone
		}

		deinit {
			if Bindings.suspendFreedom || Self.suspendFreedom {
				return
			}

			if !self.dangling {
				if Self.enableDeinitLogging {
					Bindings.print(
						"Freeing MessageSendEvent \(self.instanceNumber). (Origin: \(self.instantiationContext))")
				}

				self.free()
			} else if Self.enableDeinitLogging {
				Bindings.print(
					"Not freeing MessageSendEvent \(self.instanceNumber) due to dangle. (Origin: \(self.instantiationContext))"
				)
			}
		}


		///
		internal typealias MessageSendEvent_LDKSendAcceptChannel_Body = SendAcceptChannel


		///
		public class SendAcceptChannel: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.AcceptChannel {
				// return value (do some wrapping)
				let returnValue = Bindings.AcceptChannel(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendAcceptChannel {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendOpenChannel_Body = SendOpenChannel


		///
		public class SendOpenChannel: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendOpenChannel_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.OpenChannel {
				// return value (do some wrapping)
				let returnValue = Bindings.OpenChannel(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendOpenChannel {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendFundingCreated_Body = SendFundingCreated


		///
		public class SendFundingCreated: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendFundingCreated_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.FundingCreated {
				// return value (do some wrapping)
				let returnValue = Bindings.FundingCreated(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendFundingCreated {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendFundingSigned_Body = SendFundingSigned


		///
		public class SendFundingSigned: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendFundingSigned_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.FundingSigned {
				// return value (do some wrapping)
				let returnValue = Bindings.FundingSigned(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendFundingSigned {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelReady_Body = SendChannelReady


		///
		public class SendChannelReady: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelReady_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_ready message which should be sent.
			public func getMsg() -> Bindings.ChannelReady {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelReady(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendChannelReady {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendAnnouncementSignatures_Body = SendAnnouncementSignatures


		///
		public class SendAnnouncementSignatures: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The announcement_signatures message which should be sent.
			public func getMsg() -> Bindings.AnnouncementSignatures {
				// return value (do some wrapping)
				let returnValue = Bindings.AnnouncementSignatures(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendAnnouncementSignatures {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKUpdateHTLCs_Body = UpdateHTLCs


		///
		public class UpdateHTLCs: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body?

			internal init(cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String, anchor: NativeTypeWrapper,
				dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The update messages which should be sent. ALL messages in the struct should be sent!
			public func getUpdates() -> Bindings.CommitmentUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.CommitmentUpdate(
					cType: self.cType!.updates, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> UpdateHTLCs {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendRevokeAndACK_Body = SendRevokeAndACK


		///
		public class SendRevokeAndACK: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.RevokeAndACK {
				// return value (do some wrapping)
				let returnValue = Bindings.RevokeAndACK(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendRevokeAndACK {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendClosingSigned_Body = SendClosingSigned


		///
		public class SendClosingSigned: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendClosingSigned_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.ClosingSigned {
				// return value (do some wrapping)
				let returnValue = Bindings.ClosingSigned(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendClosingSigned {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendShutdown_Body = SendShutdown


		///
		public class SendShutdown: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendShutdown_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.Shutdown {
				// return value (do some wrapping)
				let returnValue = Bindings.Shutdown(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendShutdown {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelReestablish_Body = SendChannelReestablish


		///
		public class SendChannelReestablish: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.ChannelReestablish {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelReestablish(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendChannelReestablish {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelAnnouncement_Body = SendChannelAnnouncement


		///
		public class SendChannelAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_announcement which should be sent.
			public func getMsg() -> Bindings.ChannelAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}

			/// The followup channel_update which should be sent.
			public func getUpdateMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.update_msg,
					instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendChannelAnnouncement {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastChannelAnnouncement_Body = BroadcastChannelAnnouncement


		///
		public class BroadcastChannelAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String)
			{
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The channel_announcement which should be sent.
			public func getMsg() -> Bindings.ChannelAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}

			/// The followup channel_update which should be sent.
			///
			/// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
			public func getUpdateMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.update_msg,
					instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> BroadcastChannelAnnouncement {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastChannelUpdate_Body = BroadcastChannelUpdate


		///
		public class BroadcastChannelUpdate: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The channel_update which should be sent.
			public func getMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> BroadcastChannelUpdate {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastNodeAnnouncement_Body = BroadcastNodeAnnouncement


		///
		public class BroadcastNodeAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_announcement which should be sent.
			public func getMsg() -> Bindings.NodeAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.NodeAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> BroadcastNodeAnnouncement {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelUpdate_Body = SendChannelUpdate


		///
		public class SendChannelUpdate: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_update which should be sent.
			public func getMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendChannelUpdate {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKHandleError_Body = HandleError


		///
		public class HandleError: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKHandleError_Body?

			internal init(cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String, anchor: NativeTypeWrapper,
				dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The action which should be taken.
			public func getAction() -> ErrorAction {
				// return value (do some wrapping)
				let returnValue = ErrorAction(
					cType: self.cType!.action, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> HandleError {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelRangeQuery_Body = SendChannelRangeQuery


		///
		public class SendChannelRangeQuery: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The query_channel_range which should be sent.
			public func getMsg() -> Bindings.QueryChannelRange {
				// return value (do some wrapping)
				let returnValue = Bindings.QueryChannelRange(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendChannelRangeQuery {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendShortIdsQuery_Body = SendShortIdsQuery


		///
		public class SendShortIdsQuery: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The query_short_channel_ids which should be sent.
			public func getMsg() -> Bindings.QueryShortChannelIds {
				// return value (do some wrapping)
				let returnValue = Bindings.QueryShortChannelIds(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendShortIdsQuery {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendReplyChannelRange_Body = SendReplyChannelRange


		///
		public class SendReplyChannelRange: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The reply_channel_range which should be sent.
			public func getMsg() -> Bindings.ReplyChannelRange {
				// return value (do some wrapping)
				let returnValue = Bindings.ReplyChannelRange(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendReplyChannelRange {
				self.dangling = shouldDangle
				return self
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendGossipTimestampFilter_Body = SendGossipTimestampFilter


		///
		public class SendGossipTimestampFilter: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The gossip_timestamp_filter which should be sent.
			public func getMsg() -> Bindings.GossipTimestampFilter {
				// return value (do some wrapping)
				let returnValue = Bindings.GossipTimestampFilter(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


			internal func dangle(_ shouldDangle: Bool = true) -> SendGossipTimestampFilter {
				self.dangling = shouldDangle
				return self
			}


		}


	}

}
