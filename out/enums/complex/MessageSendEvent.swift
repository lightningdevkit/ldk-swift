import Foundation

#if SWIFT_PACKAGE
	import LDKHeaders
#endif


///
public typealias MessageSendEvent = Bindings.MessageSendEvent

extension Bindings {

	/// An event generated by ChannelManager which indicates a message should be sent to a peer (or
	/// broadcast to most peers).
	/// These events are handled by PeerManager::process_events if you are using a PeerManager.
	public class MessageSendEvent: NativeTypeWrapper {


		/// Set to false to suppress an individual type's deinit log statements.
		/// Only applicable when log threshold is set to `.Debug`.
		public static var enableDeinitLogging = true

		/// Set to true to suspend the freeing of this type's associated Rust memory.
		/// Should only ever be used for debugging purposes, and will likely be
		/// deprecated soon.
		public static var suspendFreedom = false

		private static var instanceCounter: UInt = 0
		internal let instanceNumber: UInt

		internal var cType: LDKMessageSendEvent?

		internal init(cType: LDKMessageSendEvent, instantiationContext: String) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
		}

		internal init(cType: LDKMessageSendEvent, instantiationContext: String, anchor: NativeTypeWrapper) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			self.dangling = true
			try! self.addAnchor(anchor: anchor)
		}

		internal init(
			cType: LDKMessageSendEvent, instantiationContext: String, anchor: NativeTypeWrapper, dangle: Bool = false
		) {
			Self.instanceCounter += 1
			self.instanceNumber = Self.instanceCounter
			self.cType = cType

			super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			self.dangling = dangle
			try! self.addAnchor(anchor: anchor)
		}


		public enum MessageSendEventType {

			/// Used to indicate that we've accepted a channel open and should send the accept_channel
			/// message provided to the given peer.
			case SendAcceptChannel

			/// Used to indicate that we've accepted a V2 channel open and should send the accept_channel2
			/// message provided to the given peer.
			case SendAcceptChannelV2

			/// Used to indicate that we've initiated a channel open and should send the open_channel
			/// message provided to the given peer.
			case SendOpenChannel

			/// Used to indicate that we've initiated a V2 channel open and should send the open_channel2
			/// message provided to the given peer.
			case SendOpenChannelV2

			/// Used to indicate that a funding_created message should be sent to the peer with the given node_id.
			case SendFundingCreated

			/// Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
			case SendFundingSigned

			/// Used to indicate that a tx_add_input message should be sent to the peer with the given node_id.
			case SendTxAddInput

			/// Used to indicate that a tx_add_output message should be sent to the peer with the given node_id.
			case SendTxAddOutput

			/// Used to indicate that a tx_remove_input message should be sent to the peer with the given node_id.
			case SendTxRemoveInput

			/// Used to indicate that a tx_remove_output message should be sent to the peer with the given node_id.
			case SendTxRemoveOutput

			/// Used to indicate that a tx_complete message should be sent to the peer with the given node_id.
			case SendTxComplete

			/// Used to indicate that a tx_signatures message should be sent to the peer with the given node_id.
			case SendTxSignatures

			/// Used to indicate that a tx_init_rbf message should be sent to the peer with the given node_id.
			case SendTxInitRbf

			/// Used to indicate that a tx_ack_rbf message should be sent to the peer with the given node_id.
			case SendTxAckRbf

			/// Used to indicate that a tx_abort message should be sent to the peer with the given node_id.
			case SendTxAbort

			/// Used to indicate that a channel_ready message should be sent to the peer with the given node_id.
			case SendChannelReady

			/// Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
			case SendAnnouncementSignatures

			/// Used to indicate that a series of HTLC update messages, as well as a commitment_signed
			/// message should be sent to the peer with the given node_id.
			case UpdateHTLCs

			/// Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
			case SendRevokeAndACK

			/// Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
			case SendClosingSigned

			/// Used to indicate that a shutdown message should be sent to the peer with the given node_id.
			case SendShutdown

			/// Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
			case SendChannelReestablish

			/// Used to send a channel_announcement and channel_update to a specific peer, likely on
			/// initial connection to ensure our peers know about our channels.
			case SendChannelAnnouncement

			/// Used to indicate that a channel_announcement and channel_update should be broadcast to all
			/// peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
			///
			/// Note that after doing so, you very likely (unless you did so very recently) want to
			/// broadcast a node_announcement (e.g. via [`PeerManager::broadcast_node_announcement`]). This
			/// ensures that any nodes which see our channel_announcement also have a relevant
			/// node_announcement, including relevant feature flags which may be important for routing
			/// through or to us.
			///
			/// [`PeerManager::broadcast_node_announcement`]: crate::ln::peer_handler::PeerManager::broadcast_node_announcement
			case BroadcastChannelAnnouncement

			/// Used to indicate that a channel_update should be broadcast to all peers.
			case BroadcastChannelUpdate

			/// Used to indicate that a node_announcement should be broadcast to all peers.
			case BroadcastNodeAnnouncement

			/// Used to indicate that a channel_update should be sent to a single peer.
			/// In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
			/// private channel and we shouldn't be informing all of our peers of channel parameters.
			case SendChannelUpdate

			/// Broadcast an error downstream to be handled
			case HandleError

			/// Query a peer for channels with funding transaction UTXOs in a block range.
			case SendChannelRangeQuery

			/// Request routing gossip messages from a peer for a list of channels identified by
			/// their short_channel_ids.
			case SendShortIdsQuery

			/// Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
			/// emitted during processing of the query.
			case SendReplyChannelRange

			/// Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
			/// enable receiving gossip messages from the peer.
			case SendGossipTimestampFilter

		}

		public func getValueType() -> MessageSendEventType {
			switch self.cType!.tag {
				case LDKMessageSendEvent_SendAcceptChannel:
					return .SendAcceptChannel

				case LDKMessageSendEvent_SendAcceptChannelV2:
					return .SendAcceptChannelV2

				case LDKMessageSendEvent_SendOpenChannel:
					return .SendOpenChannel

				case LDKMessageSendEvent_SendOpenChannelV2:
					return .SendOpenChannelV2

				case LDKMessageSendEvent_SendFundingCreated:
					return .SendFundingCreated

				case LDKMessageSendEvent_SendFundingSigned:
					return .SendFundingSigned

				case LDKMessageSendEvent_SendTxAddInput:
					return .SendTxAddInput

				case LDKMessageSendEvent_SendTxAddOutput:
					return .SendTxAddOutput

				case LDKMessageSendEvent_SendTxRemoveInput:
					return .SendTxRemoveInput

				case LDKMessageSendEvent_SendTxRemoveOutput:
					return .SendTxRemoveOutput

				case LDKMessageSendEvent_SendTxComplete:
					return .SendTxComplete

				case LDKMessageSendEvent_SendTxSignatures:
					return .SendTxSignatures

				case LDKMessageSendEvent_SendTxInitRbf:
					return .SendTxInitRbf

				case LDKMessageSendEvent_SendTxAckRbf:
					return .SendTxAckRbf

				case LDKMessageSendEvent_SendTxAbort:
					return .SendTxAbort

				case LDKMessageSendEvent_SendChannelReady:
					return .SendChannelReady

				case LDKMessageSendEvent_SendAnnouncementSignatures:
					return .SendAnnouncementSignatures

				case LDKMessageSendEvent_UpdateHTLCs:
					return .UpdateHTLCs

				case LDKMessageSendEvent_SendRevokeAndACK:
					return .SendRevokeAndACK

				case LDKMessageSendEvent_SendClosingSigned:
					return .SendClosingSigned

				case LDKMessageSendEvent_SendShutdown:
					return .SendShutdown

				case LDKMessageSendEvent_SendChannelReestablish:
					return .SendChannelReestablish

				case LDKMessageSendEvent_SendChannelAnnouncement:
					return .SendChannelAnnouncement

				case LDKMessageSendEvent_BroadcastChannelAnnouncement:
					return .BroadcastChannelAnnouncement

				case LDKMessageSendEvent_BroadcastChannelUpdate:
					return .BroadcastChannelUpdate

				case LDKMessageSendEvent_BroadcastNodeAnnouncement:
					return .BroadcastNodeAnnouncement

				case LDKMessageSendEvent_SendChannelUpdate:
					return .SendChannelUpdate

				case LDKMessageSendEvent_HandleError:
					return .HandleError

				case LDKMessageSendEvent_SendChannelRangeQuery:
					return .SendChannelRangeQuery

				case LDKMessageSendEvent_SendShortIdsQuery:
					return .SendShortIdsQuery

				case LDKMessageSendEvent_SendReplyChannelRange:
					return .SendReplyChannelRange

				case LDKMessageSendEvent_SendGossipTimestampFilter:
					return .SendGossipTimestampFilter

				default:
					Bindings.print("Error: Invalid value type for MessageSendEvent! Aborting.", severity: .ERROR)
					abort()
			}

		}


		/// Frees any resources used by the MessageSendEvent
		internal func free() {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_free(self.cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = nativeCallResult


			return returnValue
		}

		/// Creates a copy of the MessageSendEvent
		internal func clone() -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult =
				withUnsafePointer(to: self.cType!) { (origPointer: UnsafePointer<LDKMessageSendEvent>) in
					MessageSendEvent_clone(origPointer)
				}


			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
		public class func initWithSendAcceptChannel(nodeId: [UInt8], msg: Bindings.AcceptChannel) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_accept_channel(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendAcceptChannelV2-variant MessageSendEvent
		public class func initWithSendAcceptChannelV2(nodeId: [UInt8], msg: Bindings.AcceptChannelV2)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_accept_channel_v2(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
		public class func initWithSendOpenChannel(nodeId: [UInt8], msg: Bindings.OpenChannel) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_open_channel(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendOpenChannelV2-variant MessageSendEvent
		public class func initWithSendOpenChannelV2(nodeId: [UInt8], msg: Bindings.OpenChannelV2) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_open_channel_v2(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
		public class func initWithSendFundingCreated(nodeId: [UInt8], msg: Bindings.FundingCreated) -> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_funding_created(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
		public class func initWithSendFundingSigned(nodeId: [UInt8], msg: Bindings.FundingSigned) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_funding_signed(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxAddInput-variant MessageSendEvent
		public class func initWithSendTxAddInput(nodeId: [UInt8], msg: Bindings.TxAddInput) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_add_input(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxAddOutput-variant MessageSendEvent
		public class func initWithSendTxAddOutput(nodeId: [UInt8], msg: Bindings.TxAddOutput) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_add_output(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxRemoveInput-variant MessageSendEvent
		public class func initWithSendTxRemoveInput(nodeId: [UInt8], msg: Bindings.TxRemoveInput) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_remove_input(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxRemoveOutput-variant MessageSendEvent
		public class func initWithSendTxRemoveOutput(nodeId: [UInt8], msg: Bindings.TxRemoveOutput) -> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_remove_output(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxComplete-variant MessageSendEvent
		public class func initWithSendTxComplete(nodeId: [UInt8], msg: Bindings.TxComplete) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_complete(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxSignatures-variant MessageSendEvent
		public class func initWithSendTxSignatures(nodeId: [UInt8], msg: Bindings.TxSignatures) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_signatures(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxInitRbf-variant MessageSendEvent
		public class func initWithSendTxInitRbf(nodeId: [UInt8], msg: Bindings.TxInitRbf) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_init_rbf(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxAckRbf-variant MessageSendEvent
		public class func initWithSendTxAckRbf(nodeId: [UInt8], msg: Bindings.TxAckRbf) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_ack_rbf(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendTxAbort-variant MessageSendEvent
		public class func initWithSendTxAbort(nodeId: [UInt8], msg: Bindings.TxAbort) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_tx_abort(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelReady-variant MessageSendEvent
		public class func initWithSendChannelReady(nodeId: [UInt8], msg: Bindings.ChannelReady) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_ready(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
		public class func initWithSendAnnouncementSignatures(nodeId: [UInt8], msg: Bindings.AnnouncementSignatures)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_announcement_signatures(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
		public class func initWithUpdateHtlcs(nodeId: [UInt8], updates: Bindings.CommitmentUpdate) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_update_htlcs(
				nodeIdPrimitiveWrapper.cType!, updates.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
		public class func initWithSendRevokeAndAck(nodeId: [UInt8], msg: Bindings.RevokeAndACK) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_revoke_and_ack(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
		public class func initWithSendClosingSigned(nodeId: [UInt8], msg: Bindings.ClosingSigned) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_closing_signed(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendShutdown-variant MessageSendEvent
		public class func initWithSendShutdown(nodeId: [UInt8], msg: Bindings.Shutdown) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_shutdown(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
		public class func initWithSendChannelReestablish(nodeId: [UInt8], msg: Bindings.ChannelReestablish)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_reestablish(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelAnnouncement-variant MessageSendEvent
		public class func initWithSendChannelAnnouncement(
			nodeId: [UInt8], msg: Bindings.ChannelAnnouncement, updateMsg: Bindings.ChannelUpdate
		) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_announcement(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!,
				updateMsg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
		public class func initWithBroadcastChannelAnnouncement(
			msg: Bindings.ChannelAnnouncement, updateMsg: Bindings.ChannelUpdate
		) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_channel_announcement(
				msg.dynamicallyDangledClone().cType!, updateMsg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
		public class func initWithBroadcastChannelUpdate(msg: Bindings.ChannelUpdate) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_channel_update(msg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
		public class func initWithBroadcastNodeAnnouncement(msg: Bindings.NodeAnnouncement) -> MessageSendEvent {
			// native call variable prep


			// native method call
			let nativeCallResult = MessageSendEvent_broadcast_node_announcement(msg.dynamicallyDangledClone().cType!)

			// cleanup


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
		public class func initWithSendChannelUpdate(nodeId: [UInt8], msg: Bindings.ChannelUpdate) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_update(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new HandleError-variant MessageSendEvent
		public class func initWithHandleError(nodeId: [UInt8], action: ErrorAction) -> MessageSendEvent {
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_handle_error(
				nodeIdPrimitiveWrapper.cType!, action.danglingClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
		public class func initWithSendChannelRangeQuery(nodeId: [UInt8], msg: Bindings.QueryChannelRange)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_channel_range_query(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
		public class func initWithSendShortIdsQuery(nodeId: [UInt8], msg: Bindings.QueryShortChannelIds)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_short_ids_query(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
		public class func initWithSendReplyChannelRange(nodeId: [UInt8], msg: Bindings.ReplyChannelRange)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_reply_channel_range(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}

		/// Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
		public class func initWithSendGossipTimestampFilter(nodeId: [UInt8], msg: Bindings.GossipTimestampFilter)
			-> MessageSendEvent
		{
			// native call variable prep

			let nodeIdPrimitiveWrapper = PublicKey(
				value: nodeId, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			// native method call
			let nativeCallResult = MessageSendEvent_send_gossip_timestamp_filter(
				nodeIdPrimitiveWrapper.cType!, msg.dynamicallyDangledClone().cType!)

			// cleanup

			// for elided types, we need this
			nodeIdPrimitiveWrapper.noOpRetain()


			// return value (do some wrapping)
			let returnValue = MessageSendEvent(
				cType: nativeCallResult, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)")


			return returnValue
		}


		public func getValueAsSendAcceptChannel() -> SendAcceptChannel? {
			if self.cType?.tag != LDKMessageSendEvent_SendAcceptChannel {
				return nil
			}

			return MessageSendEvent_LDKSendAcceptChannel_Body(
				cType: self.cType!.send_accept_channel,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendAcceptChannelV2() -> SendAcceptChannelV2? {
			if self.cType?.tag != LDKMessageSendEvent_SendAcceptChannelV2 {
				return nil
			}

			return MessageSendEvent_LDKSendAcceptChannelV2_Body(
				cType: self.cType!.send_accept_channel_v2,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendOpenChannel() -> SendOpenChannel? {
			if self.cType?.tag != LDKMessageSendEvent_SendOpenChannel {
				return nil
			}

			return MessageSendEvent_LDKSendOpenChannel_Body(
				cType: self.cType!.send_open_channel,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendOpenChannelV2() -> SendOpenChannelV2? {
			if self.cType?.tag != LDKMessageSendEvent_SendOpenChannelV2 {
				return nil
			}

			return MessageSendEvent_LDKSendOpenChannelV2_Body(
				cType: self.cType!.send_open_channel_v2,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendFundingCreated() -> SendFundingCreated? {
			if self.cType?.tag != LDKMessageSendEvent_SendFundingCreated {
				return nil
			}

			return MessageSendEvent_LDKSendFundingCreated_Body(
				cType: self.cType!.send_funding_created,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendFundingSigned() -> SendFundingSigned? {
			if self.cType?.tag != LDKMessageSendEvent_SendFundingSigned {
				return nil
			}

			return MessageSendEvent_LDKSendFundingSigned_Body(
				cType: self.cType!.send_funding_signed,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxAddInput() -> SendTxAddInput? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxAddInput {
				return nil
			}

			return MessageSendEvent_LDKSendTxAddInput_Body(
				cType: self.cType!.send_tx_add_input,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxAddOutput() -> SendTxAddOutput? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxAddOutput {
				return nil
			}

			return MessageSendEvent_LDKSendTxAddOutput_Body(
				cType: self.cType!.send_tx_add_output,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxRemoveInput() -> SendTxRemoveInput? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxRemoveInput {
				return nil
			}

			return MessageSendEvent_LDKSendTxRemoveInput_Body(
				cType: self.cType!.send_tx_remove_input,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxRemoveOutput() -> SendTxRemoveOutput? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxRemoveOutput {
				return nil
			}

			return MessageSendEvent_LDKSendTxRemoveOutput_Body(
				cType: self.cType!.send_tx_remove_output,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxComplete() -> SendTxComplete? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxComplete {
				return nil
			}

			return MessageSendEvent_LDKSendTxComplete_Body(
				cType: self.cType!.send_tx_complete,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxSignatures() -> SendTxSignatures? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxSignatures {
				return nil
			}

			return MessageSendEvent_LDKSendTxSignatures_Body(
				cType: self.cType!.send_tx_signatures,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxInitRbf() -> SendTxInitRbf? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxInitRbf {
				return nil
			}

			return MessageSendEvent_LDKSendTxInitRbf_Body(
				cType: self.cType!.send_tx_init_rbf,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxAckRbf() -> SendTxAckRbf? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxAckRbf {
				return nil
			}

			return MessageSendEvent_LDKSendTxAckRbf_Body(
				cType: self.cType!.send_tx_ack_rbf,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendTxAbort() -> SendTxAbort? {
			if self.cType?.tag != LDKMessageSendEvent_SendTxAbort {
				return nil
			}

			return MessageSendEvent_LDKSendTxAbort_Body(
				cType: self.cType!.send_tx_abort, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendChannelReady() -> SendChannelReady? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelReady {
				return nil
			}

			return MessageSendEvent_LDKSendChannelReady_Body(
				cType: self.cType!.send_channel_ready,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendAnnouncementSignatures() -> SendAnnouncementSignatures? {
			if self.cType?.tag != LDKMessageSendEvent_SendAnnouncementSignatures {
				return nil
			}

			return MessageSendEvent_LDKSendAnnouncementSignatures_Body(
				cType: self.cType!.send_announcement_signatures,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsUpdateHtlcs() -> UpdateHTLCs? {
			if self.cType?.tag != LDKMessageSendEvent_UpdateHTLCs {
				return nil
			}

			return MessageSendEvent_LDKUpdateHTLCs_Body(
				cType: self.cType!.update_htl_cs, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendRevokeAndAck() -> SendRevokeAndACK? {
			if self.cType?.tag != LDKMessageSendEvent_SendRevokeAndACK {
				return nil
			}

			return MessageSendEvent_LDKSendRevokeAndACK_Body(
				cType: self.cType!.send_revoke_and_ack,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendClosingSigned() -> SendClosingSigned? {
			if self.cType?.tag != LDKMessageSendEvent_SendClosingSigned {
				return nil
			}

			return MessageSendEvent_LDKSendClosingSigned_Body(
				cType: self.cType!.send_closing_signed,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendShutdown() -> SendShutdown? {
			if self.cType?.tag != LDKMessageSendEvent_SendShutdown {
				return nil
			}

			return MessageSendEvent_LDKSendShutdown_Body(
				cType: self.cType!.send_shutdown, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendChannelReestablish() -> SendChannelReestablish? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelReestablish {
				return nil
			}

			return MessageSendEvent_LDKSendChannelReestablish_Body(
				cType: self.cType!.send_channel_reestablish,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendChannelAnnouncement() -> SendChannelAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKSendChannelAnnouncement_Body(
				cType: self.cType!.send_channel_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastChannelAnnouncement() -> BroadcastChannelAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastChannelAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKBroadcastChannelAnnouncement_Body(
				cType: self.cType!.broadcast_channel_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastChannelUpdate() -> BroadcastChannelUpdate? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastChannelUpdate {
				return nil
			}

			return MessageSendEvent_LDKBroadcastChannelUpdate_Body(
				cType: self.cType!.broadcast_channel_update,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsBroadcastNodeAnnouncement() -> BroadcastNodeAnnouncement? {
			if self.cType?.tag != LDKMessageSendEvent_BroadcastNodeAnnouncement {
				return nil
			}

			return MessageSendEvent_LDKBroadcastNodeAnnouncement_Body(
				cType: self.cType!.broadcast_node_announcement,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendChannelUpdate() -> SendChannelUpdate? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelUpdate {
				return nil
			}

			return MessageSendEvent_LDKSendChannelUpdate_Body(
				cType: self.cType!.send_channel_update,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsHandleError() -> HandleError? {
			if self.cType?.tag != LDKMessageSendEvent_HandleError {
				return nil
			}

			return MessageSendEvent_LDKHandleError_Body(
				cType: self.cType!.handle_error, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
				anchor: self)
		}

		public func getValueAsSendChannelRangeQuery() -> SendChannelRangeQuery? {
			if self.cType?.tag != LDKMessageSendEvent_SendChannelRangeQuery {
				return nil
			}

			return MessageSendEvent_LDKSendChannelRangeQuery_Body(
				cType: self.cType!.send_channel_range_query,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendShortIdsQuery() -> SendShortIdsQuery? {
			if self.cType?.tag != LDKMessageSendEvent_SendShortIdsQuery {
				return nil
			}

			return MessageSendEvent_LDKSendShortIdsQuery_Body(
				cType: self.cType!.send_short_ids_query,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendReplyChannelRange() -> SendReplyChannelRange? {
			if self.cType?.tag != LDKMessageSendEvent_SendReplyChannelRange {
				return nil
			}

			return MessageSendEvent_LDKSendReplyChannelRange_Body(
				cType: self.cType!.send_reply_channel_range,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}

		public func getValueAsSendGossipTimestampFilter() -> SendGossipTimestampFilter? {
			if self.cType?.tag != LDKMessageSendEvent_SendGossipTimestampFilter {
				return nil
			}

			return MessageSendEvent_LDKSendGossipTimestampFilter_Body(
				cType: self.cType!.send_gossip_timestamp_filter,
				instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)
		}


		internal func danglingClone() -> MessageSendEvent {
			let dangledClone = self.clone()
			dangledClone.dangling = true
			return dangledClone
		}

		deinit {
			if Bindings.suspendFreedom || Self.suspendFreedom {
				return
			}

			if !self.dangling {
				if Self.enableDeinitLogging {
					Bindings.print(
						"Freeing MessageSendEvent \(self.instanceNumber). (Origin: \(self.instantiationContext))")
				}

				self.free()
			} else if Self.enableDeinitLogging {
				Bindings.print(
					"Not freeing MessageSendEvent \(self.instanceNumber) due to dangle. (Origin: \(self.instantiationContext))"
				)
			}
		}


		///
		internal typealias MessageSendEvent_LDKSendAcceptChannel_Body = SendAcceptChannel


		///
		public class SendAcceptChannel: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.AcceptChannel {
				// return value (do some wrapping)
				let returnValue = Bindings.AcceptChannel(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendAcceptChannelV2_Body = SendAcceptChannelV2


		///
		public class SendAcceptChannelV2: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendAcceptChannelV2_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendAcceptChannelV2_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannelV2_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAcceptChannelV2_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.AcceptChannelV2 {
				// return value (do some wrapping)
				let returnValue = Bindings.AcceptChannelV2(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendOpenChannel_Body = SendOpenChannel


		///
		public class SendOpenChannel: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendOpenChannel_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannel_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.OpenChannel {
				// return value (do some wrapping)
				let returnValue = Bindings.OpenChannel(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendOpenChannelV2_Body = SendOpenChannelV2


		///
		public class SendOpenChannelV2: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendOpenChannelV2_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendOpenChannelV2_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannelV2_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendOpenChannelV2_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.OpenChannelV2 {
				// return value (do some wrapping)
				let returnValue = Bindings.OpenChannelV2(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendFundingCreated_Body = SendFundingCreated


		///
		public class SendFundingCreated: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendFundingCreated_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingCreated_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.FundingCreated {
				// return value (do some wrapping)
				let returnValue = Bindings.FundingCreated(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendFundingSigned_Body = SendFundingSigned


		///
		public class SendFundingSigned: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendFundingSigned_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendFundingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.FundingSigned {
				// return value (do some wrapping)
				let returnValue = Bindings.FundingSigned(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxAddInput_Body = SendTxAddInput


		///
		public class SendTxAddInput: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxAddInput_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxAddInput_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAddInput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAddInput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxAddInput {
				// return value (do some wrapping)
				let returnValue = Bindings.TxAddInput(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxAddOutput_Body = SendTxAddOutput


		///
		public class SendTxAddOutput: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxAddOutput_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxAddOutput_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAddOutput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAddOutput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxAddOutput {
				// return value (do some wrapping)
				let returnValue = Bindings.TxAddOutput(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxRemoveInput_Body = SendTxRemoveInput


		///
		public class SendTxRemoveInput: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxRemoveInput_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxRemoveInput_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxRemoveInput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxRemoveInput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxRemoveInput {
				// return value (do some wrapping)
				let returnValue = Bindings.TxRemoveInput(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxRemoveOutput_Body = SendTxRemoveOutput


		///
		public class SendTxRemoveOutput: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxRemoveOutput_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxRemoveOutput_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxRemoveOutput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxRemoveOutput_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxRemoveOutput {
				// return value (do some wrapping)
				let returnValue = Bindings.TxRemoveOutput(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxComplete_Body = SendTxComplete


		///
		public class SendTxComplete: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxComplete_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxComplete_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxComplete_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxComplete_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxComplete {
				// return value (do some wrapping)
				let returnValue = Bindings.TxComplete(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxSignatures_Body = SendTxSignatures


		///
		public class SendTxSignatures: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxSignatures_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxSignatures_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxSignatures {
				// return value (do some wrapping)
				let returnValue = Bindings.TxSignatures(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxInitRbf_Body = SendTxInitRbf


		///
		public class SendTxInitRbf: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxInitRbf_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxInitRbf_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxInitRbf_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxInitRbf_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxInitRbf {
				// return value (do some wrapping)
				let returnValue = Bindings.TxInitRbf(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxAckRbf_Body = SendTxAckRbf


		///
		public class SendTxAckRbf: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxAckRbf_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxAckRbf_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAckRbf_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAckRbf_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxAckRbf {
				// return value (do some wrapping)
				let returnValue = Bindings.TxAckRbf(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendTxAbort_Body = SendTxAbort


		///
		public class SendTxAbort: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendTxAbort_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendTxAbort_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAbort_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendTxAbort_Body, instantiationContext: String, anchor: NativeTypeWrapper,
				dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.TxAbort {
				// return value (do some wrapping)
				let returnValue = Bindings.TxAbort(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelReady_Body = SendChannelReady


		///
		public class SendChannelReady: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelReady_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReady_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_ready message which should be sent.
			public func getMsg() -> Bindings.ChannelReady {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelReady(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendAnnouncementSignatures_Body = SendAnnouncementSignatures


		///
		public class SendAnnouncementSignatures: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The announcement_signatures message which should be sent.
			public func getMsg() -> Bindings.AnnouncementSignatures {
				// return value (do some wrapping)
				let returnValue = Bindings.AnnouncementSignatures(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKUpdateHTLCs_Body = UpdateHTLCs


		///
		public class UpdateHTLCs: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body?

			internal init(cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKUpdateHTLCs_Body, instantiationContext: String, anchor: NativeTypeWrapper,
				dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive these message(s)
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The update messages which should be sent. ALL messages in the struct should be sent!
			public func getUpdates() -> Bindings.CommitmentUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.CommitmentUpdate(
					cType: self.cType!.updates, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendRevokeAndACK_Body = SendRevokeAndACK


		///
		public class SendRevokeAndACK: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendRevokeAndACK_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.RevokeAndACK {
				// return value (do some wrapping)
				let returnValue = Bindings.RevokeAndACK(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendClosingSigned_Body = SendClosingSigned


		///
		public class SendClosingSigned: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendClosingSigned_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendClosingSigned_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.ClosingSigned {
				// return value (do some wrapping)
				let returnValue = Bindings.ClosingSigned(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendShutdown_Body = SendShutdown


		///
		public class SendShutdown: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendShutdown_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShutdown_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.Shutdown {
				// return value (do some wrapping)
				let returnValue = Bindings.Shutdown(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelReestablish_Body = SendChannelReestablish


		///
		public class SendChannelReestablish: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelReestablish_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The message which should be sent.
			public func getMsg() -> Bindings.ChannelReestablish {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelReestablish(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelAnnouncement_Body = SendChannelAnnouncement


		///
		public class SendChannelAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_announcement which should be sent.
			public func getMsg() -> Bindings.ChannelAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}

			/// The followup channel_update which should be sent.
			public func getUpdateMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.update_msg,
					instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastChannelAnnouncement_Body = BroadcastChannelAnnouncement


		///
		public class BroadcastChannelAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String)
			{
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The channel_announcement which should be sent.
			public func getMsg() -> Bindings.ChannelAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}

			/// The followup channel_update which should be sent.
			///
			/// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
			public func getUpdateMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.update_msg,
					instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)", anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastChannelUpdate_Body = BroadcastChannelUpdate


		///
		public class BroadcastChannelUpdate: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The channel_update which should be sent.
			public func getMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKBroadcastNodeAnnouncement_Body = BroadcastNodeAnnouncement


		///
		public class BroadcastNodeAnnouncement: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body?

			internal init(cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_announcement which should be sent.
			public func getMsg() -> Bindings.NodeAnnouncement {
				// return value (do some wrapping)
				let returnValue = Bindings.NodeAnnouncement(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelUpdate_Body = SendChannelUpdate


		///
		public class SendChannelUpdate: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelUpdate_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The channel_update which should be sent.
			public func getMsg() -> Bindings.ChannelUpdate {
				// return value (do some wrapping)
				let returnValue = Bindings.ChannelUpdate(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKHandleError_Body = HandleError


		///
		public class HandleError: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKHandleError_Body?

			internal init(cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String, anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKHandleError_Body, instantiationContext: String, anchor: NativeTypeWrapper,
				dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of the node which should receive this message
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The action which should be taken.
			public func getAction() -> ErrorAction {
				// return value (do some wrapping)
				let returnValue = ErrorAction(
					cType: self.cType!.action, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendChannelRangeQuery_Body = SendChannelRangeQuery


		///
		public class SendChannelRangeQuery: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendChannelRangeQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The query_channel_range which should be sent.
			public func getMsg() -> Bindings.QueryChannelRange {
				// return value (do some wrapping)
				let returnValue = Bindings.QueryChannelRange(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendShortIdsQuery_Body = SendShortIdsQuery


		///
		public class SendShortIdsQuery: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendShortIdsQuery_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The query_short_channel_ids which should be sent.
			public func getMsg() -> Bindings.QueryShortChannelIds {
				// return value (do some wrapping)
				let returnValue = Bindings.QueryShortChannelIds(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendReplyChannelRange_Body = SendReplyChannelRange


		///
		public class SendReplyChannelRange: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendReplyChannelRange_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The reply_channel_range which should be sent.
			public func getMsg() -> Bindings.ReplyChannelRange {
				// return value (do some wrapping)
				let returnValue = Bindings.ReplyChannelRange(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


		///
		internal typealias MessageSendEvent_LDKSendGossipTimestampFilter_Body = SendGossipTimestampFilter


		///
		public class SendGossipTimestampFilter: NativeTypeWrapper {


			/// Set to false to suppress an individual type's deinit log statements.
			/// Only applicable when log threshold is set to `.Debug`.
			public static var enableDeinitLogging = true

			/// Set to true to suspend the freeing of this type's associated Rust memory.
			/// Should only ever be used for debugging purposes, and will likely be
			/// deprecated soon.
			public static var suspendFreedom = false

			private static var instanceCounter: UInt = 0
			internal let instanceNumber: UInt

			internal var cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body?

			internal init(cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String,
				anchor: NativeTypeWrapper
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = true
				try! self.addAnchor(anchor: anchor)
			}

			internal init(
				cType: LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body, instantiationContext: String,
				anchor: NativeTypeWrapper, dangle: Bool = false
			) {
				Self.instanceCounter += 1
				self.instanceNumber = Self.instanceCounter
				self.cType = cType

				super.init(conflictAvoidingVariableName: 0, instantiationContext: instantiationContext)
				self.dangling = dangle
				try! self.addAnchor(anchor: anchor)
			}


			/// The node_id of this message recipient
			public func getNodeId() -> [UInt8] {
				// return value (do some wrapping)
				let returnValue = PublicKey(
					cType: self.cType!.node_id, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self
				)
				.getValue()

				return returnValue
			}

			/// The gossip_timestamp_filter which should be sent.
			public func getMsg() -> Bindings.GossipTimestampFilter {
				// return value (do some wrapping)
				let returnValue = Bindings.GossipTimestampFilter(
					cType: self.cType!.msg, instantiationContext: "MessageSendEvent.swift::\(#function):\(#line)",
					anchor: self)

				return returnValue
			}


		}


	}

}
